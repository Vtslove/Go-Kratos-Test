// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kratos-blog/app/comment/service/internal/data/ent/comment"
	"kratos-blog/app/comment/service/internal/data/ent/predicate"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComment = "Comment"
)

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	create_time        *int64
	addcreate_time     *int64
	update_time        *int64
	addupdate_time     *int64
	delete_time        *int64
	adddelete_time     *int64
	author             *string
	email              *string
	ip_address         *string
	author_url         *string
	gravatar_md5       *string
	content            *string
	user_agent         *string
	avatar             *string
	parent_id          *uint32
	addparent_id       *int32
	status             *uint32
	addstatus          *int32
	is_admin           *bool
	allow_notification *bool
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Comment, error)
	predicates         []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uint32) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CommentMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CommentMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *CommentMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *CommentMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *CommentMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[comment.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *CommentMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[comment.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CommentMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, comment.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *CommentMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CommentMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *CommentMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *CommentMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *CommentMutation) ClearUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	m.clearedFields[comment.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *CommentMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[comment.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CommentMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	delete(m.clearedFields, comment.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *CommentMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CommentMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeleteTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *CommentMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *CommentMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CommentMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	m.clearedFields[comment.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CommentMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CommentMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	delete(m.clearedFields, comment.FieldDeleteTime)
}

// SetAuthor sets the "author" field.
func (m *CommentMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *CommentMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *CommentMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[comment.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *CommentMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[comment.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, comment.FieldAuthor)
}

// SetEmail sets the "email" field.
func (m *CommentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CommentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CommentMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[comment.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CommentMutation) EmailCleared() bool {
	_, ok := m.clearedFields[comment.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CommentMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, comment.FieldEmail)
}

// SetIPAddress sets the "ip_address" field.
func (m *CommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *CommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *CommentMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[comment.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *CommentMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[comment.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *CommentMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, comment.FieldIPAddress)
}

// SetAuthorURL sets the "author_url" field.
func (m *CommentMutation) SetAuthorURL(s string) {
	m.author_url = &s
}

// AuthorURL returns the value of the "author_url" field in the mutation.
func (m *CommentMutation) AuthorURL() (r string, exists bool) {
	v := m.author_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorURL returns the old "author_url" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthorURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorURL: %w", err)
	}
	return oldValue.AuthorURL, nil
}

// ClearAuthorURL clears the value of the "author_url" field.
func (m *CommentMutation) ClearAuthorURL() {
	m.author_url = nil
	m.clearedFields[comment.FieldAuthorURL] = struct{}{}
}

// AuthorURLCleared returns if the "author_url" field was cleared in this mutation.
func (m *CommentMutation) AuthorURLCleared() bool {
	_, ok := m.clearedFields[comment.FieldAuthorURL]
	return ok
}

// ResetAuthorURL resets all changes to the "author_url" field.
func (m *CommentMutation) ResetAuthorURL() {
	m.author_url = nil
	delete(m.clearedFields, comment.FieldAuthorURL)
}

// SetGravatarMd5 sets the "gravatar_md5" field.
func (m *CommentMutation) SetGravatarMd5(s string) {
	m.gravatar_md5 = &s
}

// GravatarMd5 returns the value of the "gravatar_md5" field in the mutation.
func (m *CommentMutation) GravatarMd5() (r string, exists bool) {
	v := m.gravatar_md5
	if v == nil {
		return
	}
	return *v, true
}

// OldGravatarMd5 returns the old "gravatar_md5" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldGravatarMd5(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGravatarMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGravatarMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGravatarMd5: %w", err)
	}
	return oldValue.GravatarMd5, nil
}

// ClearGravatarMd5 clears the value of the "gravatar_md5" field.
func (m *CommentMutation) ClearGravatarMd5() {
	m.gravatar_md5 = nil
	m.clearedFields[comment.FieldGravatarMd5] = struct{}{}
}

// GravatarMd5Cleared returns if the "gravatar_md5" field was cleared in this mutation.
func (m *CommentMutation) GravatarMd5Cleared() bool {
	_, ok := m.clearedFields[comment.FieldGravatarMd5]
	return ok
}

// ResetGravatarMd5 resets all changes to the "gravatar_md5" field.
func (m *CommentMutation) ResetGravatarMd5() {
	m.gravatar_md5 = nil
	delete(m.clearedFields, comment.FieldGravatarMd5)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[comment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[comment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, comment.FieldContent)
}

// SetUserAgent sets the "user_agent" field.
func (m *CommentMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *CommentMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *CommentMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[comment.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *CommentMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *CommentMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, comment.FieldUserAgent)
}

// SetAvatar sets the "avatar" field.
func (m *CommentMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *CommentMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAvatar(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *CommentMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[comment.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *CommentMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[comment.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *CommentMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, comment.FieldAvatar)
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(u uint32) {
	m.parent_id = &u
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r uint32, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds u to the "parent_id" field.
func (m *CommentMutation) AddParentID(u int32) {
	if m.addparent_id != nil {
		*m.addparent_id += u
	} else {
		m.addparent_id = &u
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *CommentMutation) AddedParentID() (r int32, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(u uint32) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r uint32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CommentMutation) AddStatus(u int32) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommentMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CommentMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[comment.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CommentMutation) StatusCleared() bool {
	_, ok := m.clearedFields[comment.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, comment.FieldStatus)
}

// SetIsAdmin sets the "is_admin" field.
func (m *CommentMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *CommentMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsAdmin(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ClearIsAdmin clears the value of the "is_admin" field.
func (m *CommentMutation) ClearIsAdmin() {
	m.is_admin = nil
	m.clearedFields[comment.FieldIsAdmin] = struct{}{}
}

// IsAdminCleared returns if the "is_admin" field was cleared in this mutation.
func (m *CommentMutation) IsAdminCleared() bool {
	_, ok := m.clearedFields[comment.FieldIsAdmin]
	return ok
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *CommentMutation) ResetIsAdmin() {
	m.is_admin = nil
	delete(m.clearedFields, comment.FieldIsAdmin)
}

// SetAllowNotification sets the "allow_notification" field.
func (m *CommentMutation) SetAllowNotification(b bool) {
	m.allow_notification = &b
}

// AllowNotification returns the value of the "allow_notification" field in the mutation.
func (m *CommentMutation) AllowNotification() (r bool, exists bool) {
	v := m.allow_notification
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowNotification returns the old "allow_notification" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAllowNotification(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowNotification: %w", err)
	}
	return oldValue.AllowNotification, nil
}

// ClearAllowNotification clears the value of the "allow_notification" field.
func (m *CommentMutation) ClearAllowNotification() {
	m.allow_notification = nil
	m.clearedFields[comment.FieldAllowNotification] = struct{}{}
}

// AllowNotificationCleared returns if the "allow_notification" field was cleared in this mutation.
func (m *CommentMutation) AllowNotificationCleared() bool {
	_, ok := m.clearedFields[comment.FieldAllowNotification]
	return ok
}

// ResetAllowNotification resets all changes to the "allow_notification" field.
func (m *CommentMutation) ResetAllowNotification() {
	m.allow_notification = nil
	delete(m.clearedFields, comment.FieldAllowNotification)
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.create_time != nil {
		fields = append(fields, comment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, comment.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, comment.FieldDeleteTime)
	}
	if m.author != nil {
		fields = append(fields, comment.FieldAuthor)
	}
	if m.email != nil {
		fields = append(fields, comment.FieldEmail)
	}
	if m.ip_address != nil {
		fields = append(fields, comment.FieldIPAddress)
	}
	if m.author_url != nil {
		fields = append(fields, comment.FieldAuthorURL)
	}
	if m.gravatar_md5 != nil {
		fields = append(fields, comment.FieldGravatarMd5)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.user_agent != nil {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.avatar != nil {
		fields = append(fields, comment.FieldAvatar)
	}
	if m.parent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.is_admin != nil {
		fields = append(fields, comment.FieldIsAdmin)
	}
	if m.allow_notification != nil {
		fields = append(fields, comment.FieldAllowNotification)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreateTime:
		return m.CreateTime()
	case comment.FieldUpdateTime:
		return m.UpdateTime()
	case comment.FieldDeleteTime:
		return m.DeleteTime()
	case comment.FieldAuthor:
		return m.Author()
	case comment.FieldEmail:
		return m.Email()
	case comment.FieldIPAddress:
		return m.IPAddress()
	case comment.FieldAuthorURL:
		return m.AuthorURL()
	case comment.FieldGravatarMd5:
		return m.GravatarMd5()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldUserAgent:
		return m.UserAgent()
	case comment.FieldAvatar:
		return m.Avatar()
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldIsAdmin:
		return m.IsAdmin()
	case comment.FieldAllowNotification:
		return m.AllowNotification()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case comment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case comment.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case comment.FieldAuthor:
		return m.OldAuthor(ctx)
	case comment.FieldEmail:
		return m.OldEmail(ctx)
	case comment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case comment.FieldAuthorURL:
		return m.OldAuthorURL(ctx)
	case comment.FieldGravatarMd5:
		return m.OldGravatarMd5(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case comment.FieldAvatar:
		return m.OldAvatar(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case comment.FieldAllowNotification:
		return m.OldAllowNotification(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case comment.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case comment.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case comment.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case comment.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case comment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case comment.FieldAuthorURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorURL(v)
		return nil
	case comment.FieldGravatarMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGravatarMd5(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case comment.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case comment.FieldAllowNotification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowNotification(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, comment.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, comment.FieldUpdateTime)
	}
	if m.adddelete_time != nil {
		fields = append(fields, comment.FieldDeleteTime)
	}
	if m.addparent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.addstatus != nil {
		fields = append(fields, comment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreateTime:
		return m.AddedCreateTime()
	case comment.FieldUpdateTime:
		return m.AddedUpdateTime()
	case comment.FieldDeleteTime:
		return m.AddedDeleteTime()
	case comment.FieldParentID:
		return m.AddedParentID()
	case comment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case comment.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case comment.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldCreateTime) {
		fields = append(fields, comment.FieldCreateTime)
	}
	if m.FieldCleared(comment.FieldUpdateTime) {
		fields = append(fields, comment.FieldUpdateTime)
	}
	if m.FieldCleared(comment.FieldDeleteTime) {
		fields = append(fields, comment.FieldDeleteTime)
	}
	if m.FieldCleared(comment.FieldAuthor) {
		fields = append(fields, comment.FieldAuthor)
	}
	if m.FieldCleared(comment.FieldEmail) {
		fields = append(fields, comment.FieldEmail)
	}
	if m.FieldCleared(comment.FieldIPAddress) {
		fields = append(fields, comment.FieldIPAddress)
	}
	if m.FieldCleared(comment.FieldAuthorURL) {
		fields = append(fields, comment.FieldAuthorURL)
	}
	if m.FieldCleared(comment.FieldGravatarMd5) {
		fields = append(fields, comment.FieldGravatarMd5)
	}
	if m.FieldCleared(comment.FieldContent) {
		fields = append(fields, comment.FieldContent)
	}
	if m.FieldCleared(comment.FieldUserAgent) {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.FieldCleared(comment.FieldAvatar) {
		fields = append(fields, comment.FieldAvatar)
	}
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	if m.FieldCleared(comment.FieldStatus) {
		fields = append(fields, comment.FieldStatus)
	}
	if m.FieldCleared(comment.FieldIsAdmin) {
		fields = append(fields, comment.FieldIsAdmin)
	}
	if m.FieldCleared(comment.FieldAllowNotification) {
		fields = append(fields, comment.FieldAllowNotification)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case comment.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case comment.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case comment.FieldAuthor:
		m.ClearAuthor()
		return nil
	case comment.FieldEmail:
		m.ClearEmail()
		return nil
	case comment.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case comment.FieldAuthorURL:
		m.ClearAuthorURL()
		return nil
	case comment.FieldGravatarMd5:
		m.ClearGravatarMd5()
		return nil
	case comment.FieldContent:
		m.ClearContent()
		return nil
	case comment.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case comment.FieldAvatar:
		m.ClearAvatar()
		return nil
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	case comment.FieldStatus:
		m.ClearStatus()
		return nil
	case comment.FieldIsAdmin:
		m.ClearIsAdmin()
		return nil
	case comment.FieldAllowNotification:
		m.ClearAllowNotification()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case comment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case comment.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case comment.FieldAuthor:
		m.ResetAuthor()
		return nil
	case comment.FieldEmail:
		m.ResetEmail()
		return nil
	case comment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case comment.FieldAuthorURL:
		m.ResetAuthorURL()
		return nil
	case comment.FieldGravatarMd5:
		m.ResetGravatarMd5()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case comment.FieldAvatar:
		m.ResetAvatar()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case comment.FieldAllowNotification:
		m.ResetAllowNotification()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}
