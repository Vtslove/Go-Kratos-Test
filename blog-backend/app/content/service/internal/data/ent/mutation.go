// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kratos-blog/app/content/service/internal/data/ent/category"
	"kratos-blog/app/content/service/internal/data/ent/link"
	"kratos-blog/app/content/service/internal/data/ent/menu"
	"kratos-blog/app/content/service/internal/data/ent/photo"
	"kratos-blog/app/content/service/internal/data/ent/post"
	"kratos-blog/app/content/service/internal/data/ent/predicate"
	"kratos-blog/app/content/service/internal/data/ent/tag"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory = "Category"
	TypeLink     = "Link"
	TypeMenu     = "Menu"
	TypePhoto    = "Photo"
	TypePost     = "Post"
	TypeTag      = "Tag"
)

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	create_time    *int64
	addcreate_time *int64
	update_time    *int64
	addupdate_time *int64
	delete_time    *int64
	adddelete_time *int64
	name           *string
	slug           *string
	description    *string
	thumbnail      *string
	password       *string
	full_path      *string
	parent_id      *uint32
	addparent_id   *int32
	priority       *int32
	addpriority    *int32
	post_count     *uint32
	addpost_count  *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Category, error)
	predicates     []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id uint32) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CategoryMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CategoryMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *CategoryMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *CategoryMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *CategoryMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[category.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *CategoryMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[category.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CategoryMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, category.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *CategoryMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CategoryMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *CategoryMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *CategoryMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *CategoryMutation) ClearUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	m.clearedFields[category.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *CategoryMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[category.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CategoryMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	delete(m.clearedFields, category.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *CategoryMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CategoryMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeleteTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *CategoryMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *CategoryMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CategoryMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	m.clearedFields[category.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CategoryMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[category.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CategoryMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	delete(m.clearedFields, category.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CategoryMutation) ClearName() {
	m.name = nil
	m.clearedFields[category.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CategoryMutation) NameCleared() bool {
	_, ok := m.clearedFields[category.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, category.FieldName)
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *CategoryMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[category.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *CategoryMutation) SlugCleared() bool {
	_, ok := m.clearedFields[category.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, category.FieldSlug)
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetThumbnail sets the "thumbnail" field.
func (m *CategoryMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *CategoryMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldThumbnail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *CategoryMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[category.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *CategoryMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[category.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *CategoryMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, category.FieldThumbnail)
}

// SetPassword sets the "password" field.
func (m *CategoryMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *CategoryMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *CategoryMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[category.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *CategoryMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[category.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *CategoryMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, category.FieldPassword)
}

// SetFullPath sets the "full_path" field.
func (m *CategoryMutation) SetFullPath(s string) {
	m.full_path = &s
}

// FullPath returns the value of the "full_path" field in the mutation.
func (m *CategoryMutation) FullPath() (r string, exists bool) {
	v := m.full_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFullPath returns the old "full_path" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldFullPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullPath: %w", err)
	}
	return oldValue.FullPath, nil
}

// ClearFullPath clears the value of the "full_path" field.
func (m *CategoryMutation) ClearFullPath() {
	m.full_path = nil
	m.clearedFields[category.FieldFullPath] = struct{}{}
}

// FullPathCleared returns if the "full_path" field was cleared in this mutation.
func (m *CategoryMutation) FullPathCleared() bool {
	_, ok := m.clearedFields[category.FieldFullPath]
	return ok
}

// ResetFullPath resets all changes to the "full_path" field.
func (m *CategoryMutation) ResetFullPath() {
	m.full_path = nil
	delete(m.clearedFields, category.FieldFullPath)
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(u uint32) {
	m.parent_id = &u
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r uint32, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds u to the "parent_id" field.
func (m *CategoryMutation) AddParentID(u int32) {
	if m.addparent_id != nil {
		*m.addparent_id += u
	} else {
		m.addparent_id = &u
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *CategoryMutation) AddedParentID() (r int32, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, category.FieldParentID)
}

// SetPriority sets the "priority" field.
func (m *CategoryMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *CategoryMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldPriority(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *CategoryMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *CategoryMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *CategoryMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[category.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *CategoryMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[category.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *CategoryMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, category.FieldPriority)
}

// SetPostCount sets the "post_count" field.
func (m *CategoryMutation) SetPostCount(u uint32) {
	m.post_count = &u
	m.addpost_count = nil
}

// PostCount returns the value of the "post_count" field in the mutation.
func (m *CategoryMutation) PostCount() (r uint32, exists bool) {
	v := m.post_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCount returns the old "post_count" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldPostCount(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCount: %w", err)
	}
	return oldValue.PostCount, nil
}

// AddPostCount adds u to the "post_count" field.
func (m *CategoryMutation) AddPostCount(u int32) {
	if m.addpost_count != nil {
		*m.addpost_count += u
	} else {
		m.addpost_count = &u
	}
}

// AddedPostCount returns the value that was added to the "post_count" field in this mutation.
func (m *CategoryMutation) AddedPostCount() (r int32, exists bool) {
	v := m.addpost_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearPostCount clears the value of the "post_count" field.
func (m *CategoryMutation) ClearPostCount() {
	m.post_count = nil
	m.addpost_count = nil
	m.clearedFields[category.FieldPostCount] = struct{}{}
}

// PostCountCleared returns if the "post_count" field was cleared in this mutation.
func (m *CategoryMutation) PostCountCleared() bool {
	_, ok := m.clearedFields[category.FieldPostCount]
	return ok
}

// ResetPostCount resets all changes to the "post_count" field.
func (m *CategoryMutation) ResetPostCount() {
	m.post_count = nil
	m.addpost_count = nil
	delete(m.clearedFields, category.FieldPostCount)
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, category.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, category.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.thumbnail != nil {
		fields = append(fields, category.FieldThumbnail)
	}
	if m.password != nil {
		fields = append(fields, category.FieldPassword)
	}
	if m.full_path != nil {
		fields = append(fields, category.FieldFullPath)
	}
	if m.parent_id != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.priority != nil {
		fields = append(fields, category.FieldPriority)
	}
	if m.post_count != nil {
		fields = append(fields, category.FieldPostCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreateTime:
		return m.CreateTime()
	case category.FieldUpdateTime:
		return m.UpdateTime()
	case category.FieldDeleteTime:
		return m.DeleteTime()
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldDescription:
		return m.Description()
	case category.FieldThumbnail:
		return m.Thumbnail()
	case category.FieldPassword:
		return m.Password()
	case category.FieldFullPath:
		return m.FullPath()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldPriority:
		return m.Priority()
	case category.FieldPostCount:
		return m.PostCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case category.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case category.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case category.FieldPassword:
		return m.OldPassword(ctx)
	case category.FieldFullPath:
		return m.OldFullPath(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldPriority:
		return m.OldPriority(ctx)
	case category.FieldPostCount:
		return m.OldPostCount(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case category.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case category.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case category.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case category.FieldFullPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullPath(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case category.FieldPostCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCount(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, category.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.adddelete_time != nil {
		fields = append(fields, category.FieldDeleteTime)
	}
	if m.addparent_id != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.addpriority != nil {
		fields = append(fields, category.FieldPriority)
	}
	if m.addpost_count != nil {
		fields = append(fields, category.FieldPostCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreateTime:
		return m.AddedCreateTime()
	case category.FieldUpdateTime:
		return m.AddedUpdateTime()
	case category.FieldDeleteTime:
		return m.AddedDeleteTime()
	case category.FieldParentID:
		return m.AddedParentID()
	case category.FieldPriority:
		return m.AddedPriority()
	case category.FieldPostCount:
		return m.AddedPostCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case category.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case category.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case category.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case category.FieldPostCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCount(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldCreateTime) {
		fields = append(fields, category.FieldCreateTime)
	}
	if m.FieldCleared(category.FieldUpdateTime) {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.FieldCleared(category.FieldDeleteTime) {
		fields = append(fields, category.FieldDeleteTime)
	}
	if m.FieldCleared(category.FieldName) {
		fields = append(fields, category.FieldName)
	}
	if m.FieldCleared(category.FieldSlug) {
		fields = append(fields, category.FieldSlug)
	}
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	if m.FieldCleared(category.FieldThumbnail) {
		fields = append(fields, category.FieldThumbnail)
	}
	if m.FieldCleared(category.FieldPassword) {
		fields = append(fields, category.FieldPassword)
	}
	if m.FieldCleared(category.FieldFullPath) {
		fields = append(fields, category.FieldFullPath)
	}
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	if m.FieldCleared(category.FieldPriority) {
		fields = append(fields, category.FieldPriority)
	}
	if m.FieldCleared(category.FieldPostCount) {
		fields = append(fields, category.FieldPostCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case category.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case category.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case category.FieldName:
		m.ClearName()
		return nil
	case category.FieldSlug:
		m.ClearSlug()
		return nil
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	case category.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	case category.FieldPassword:
		m.ClearPassword()
		return nil
	case category.FieldFullPath:
		m.ClearFullPath()
		return nil
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	case category.FieldPriority:
		m.ClearPriority()
		return nil
	case category.FieldPostCount:
		m.ClearPostCount()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case category.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case category.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case category.FieldPassword:
		m.ResetPassword()
		return nil
	case category.FieldFullPath:
		m.ResetFullPath()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldPriority:
		m.ResetPriority()
		return nil
	case category.FieldPostCount:
		m.ResetPostCount()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Category edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	create_time    *int64
	addcreate_time *int64
	update_time    *int64
	addupdate_time *int64
	delete_time    *int64
	adddelete_time *int64
	name           *string
	url            *string
	logo           *string
	description    *string
	team           *string
	priority       *int32
	addpriority    *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Link, error)
	predicates     []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id uint32) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Link entities.
func (m *LinkMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *LinkMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LinkMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldCreateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *LinkMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *LinkMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *LinkMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[link.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *LinkMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[link.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LinkMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, link.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *LinkMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LinkMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldUpdateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *LinkMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *LinkMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *LinkMutation) ClearUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	m.clearedFields[link.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *LinkMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[link.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LinkMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	delete(m.clearedFields, link.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *LinkMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *LinkMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDeleteTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *LinkMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *LinkMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *LinkMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	m.clearedFields[link.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *LinkMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[link.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *LinkMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	delete(m.clearedFields, link.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *LinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *LinkMutation) ClearName() {
	m.name = nil
	m.clearedFields[link.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *LinkMutation) NameCleared() bool {
	_, ok := m.clearedFields[link.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *LinkMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, link.FieldName)
}

// SetURL sets the "url" field.
func (m *LinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *LinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *LinkMutation) ClearURL() {
	m.url = nil
	m.clearedFields[link.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *LinkMutation) URLCleared() bool {
	_, ok := m.clearedFields[link.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *LinkMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, link.FieldURL)
}

// SetLogo sets the "logo" field.
func (m *LinkMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *LinkMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldLogo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *LinkMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[link.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *LinkMutation) LogoCleared() bool {
	_, ok := m.clearedFields[link.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *LinkMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, link.FieldLogo)
}

// SetDescription sets the "description" field.
func (m *LinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LinkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[link.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LinkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[link.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LinkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, link.FieldDescription)
}

// SetTeam sets the "team" field.
func (m *LinkMutation) SetTeam(s string) {
	m.team = &s
}

// Team returns the value of the "team" field in the mutation.
func (m *LinkMutation) Team() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeam returns the old "team" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldTeam(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeam: %w", err)
	}
	return oldValue.Team, nil
}

// ClearTeam clears the value of the "team" field.
func (m *LinkMutation) ClearTeam() {
	m.team = nil
	m.clearedFields[link.FieldTeam] = struct{}{}
}

// TeamCleared returns if the "team" field was cleared in this mutation.
func (m *LinkMutation) TeamCleared() bool {
	_, ok := m.clearedFields[link.FieldTeam]
	return ok
}

// ResetTeam resets all changes to the "team" field.
func (m *LinkMutation) ResetTeam() {
	m.team = nil
	delete(m.clearedFields, link.FieldTeam)
}

// SetPriority sets the "priority" field.
func (m *LinkMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *LinkMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldPriority(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *LinkMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *LinkMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *LinkMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[link.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *LinkMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[link.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *LinkMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, link.FieldPriority)
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Link, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, link.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, link.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, link.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, link.FieldName)
	}
	if m.url != nil {
		fields = append(fields, link.FieldURL)
	}
	if m.logo != nil {
		fields = append(fields, link.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, link.FieldDescription)
	}
	if m.team != nil {
		fields = append(fields, link.FieldTeam)
	}
	if m.priority != nil {
		fields = append(fields, link.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldCreateTime:
		return m.CreateTime()
	case link.FieldUpdateTime:
		return m.UpdateTime()
	case link.FieldDeleteTime:
		return m.DeleteTime()
	case link.FieldName:
		return m.Name()
	case link.FieldURL:
		return m.URL()
	case link.FieldLogo:
		return m.Logo()
	case link.FieldDescription:
		return m.Description()
	case link.FieldTeam:
		return m.Team()
	case link.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case link.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case link.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case link.FieldName:
		return m.OldName(ctx)
	case link.FieldURL:
		return m.OldURL(ctx)
	case link.FieldLogo:
		return m.OldLogo(ctx)
	case link.FieldDescription:
		return m.OldDescription(ctx)
	case link.FieldTeam:
		return m.OldTeam(ctx)
	case link.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case link.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case link.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case link.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case link.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case link.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case link.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case link.FieldTeam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeam(v)
		return nil
	case link.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, link.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, link.FieldUpdateTime)
	}
	if m.adddelete_time != nil {
		fields = append(fields, link.FieldDeleteTime)
	}
	if m.addpriority != nil {
		fields = append(fields, link.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case link.FieldCreateTime:
		return m.AddedCreateTime()
	case link.FieldUpdateTime:
		return m.AddedUpdateTime()
	case link.FieldDeleteTime:
		return m.AddedDeleteTime()
	case link.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case link.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case link.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case link.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case link.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldCreateTime) {
		fields = append(fields, link.FieldCreateTime)
	}
	if m.FieldCleared(link.FieldUpdateTime) {
		fields = append(fields, link.FieldUpdateTime)
	}
	if m.FieldCleared(link.FieldDeleteTime) {
		fields = append(fields, link.FieldDeleteTime)
	}
	if m.FieldCleared(link.FieldName) {
		fields = append(fields, link.FieldName)
	}
	if m.FieldCleared(link.FieldURL) {
		fields = append(fields, link.FieldURL)
	}
	if m.FieldCleared(link.FieldLogo) {
		fields = append(fields, link.FieldLogo)
	}
	if m.FieldCleared(link.FieldDescription) {
		fields = append(fields, link.FieldDescription)
	}
	if m.FieldCleared(link.FieldTeam) {
		fields = append(fields, link.FieldTeam)
	}
	if m.FieldCleared(link.FieldPriority) {
		fields = append(fields, link.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case link.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case link.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case link.FieldName:
		m.ClearName()
		return nil
	case link.FieldURL:
		m.ClearURL()
		return nil
	case link.FieldLogo:
		m.ClearLogo()
		return nil
	case link.FieldDescription:
		m.ClearDescription()
		return nil
	case link.FieldTeam:
		m.ClearTeam()
		return nil
	case link.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case link.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case link.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case link.FieldName:
		m.ResetName()
		return nil
	case link.FieldURL:
		m.ResetURL()
		return nil
	case link.FieldLogo:
		m.ResetLogo()
		return nil
	case link.FieldDescription:
		m.ResetDescription()
		return nil
	case link.FieldTeam:
		m.ResetTeam()
		return nil
	case link.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Link edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	create_time    *int64
	addcreate_time *int64
	update_time    *int64
	addupdate_time *int64
	delete_time    *int64
	adddelete_time *int64
	name           *string
	url            *string
	priority       *int32
	addpriority    *int32
	target         *string
	icon           *string
	parent_id      *uint32
	addparent_id   *int32
	team           *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Menu, error)
	predicates     []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id uint32) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MenuMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MenuMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *MenuMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *MenuMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *MenuMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[menu.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *MenuMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MenuMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, menu.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *MenuMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MenuMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *MenuMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *MenuMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *MenuMutation) ClearUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	m.clearedFields[menu.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *MenuMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MenuMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	delete(m.clearedFields, menu.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *MenuMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *MenuMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDeleteTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *MenuMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *MenuMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *MenuMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	m.clearedFields[menu.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *MenuMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[menu.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *MenuMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	delete(m.clearedFields, menu.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[menu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[menu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, menu.FieldName)
}

// SetURL sets the "url" field.
func (m *MenuMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *MenuMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *MenuMutation) ClearURL() {
	m.url = nil
	m.clearedFields[menu.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *MenuMutation) URLCleared() bool {
	_, ok := m.clearedFields[menu.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *MenuMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, menu.FieldURL)
}

// SetPriority sets the "priority" field.
func (m *MenuMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *MenuMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPriority(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *MenuMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *MenuMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *MenuMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[menu.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *MenuMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[menu.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *MenuMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, menu.FieldPriority)
}

// SetTarget sets the "target" field.
func (m *MenuMutation) SetTarget(s string) {
	m.target = &s
}

// Target returns the value of the "target" field in the mutation.
func (m *MenuMutation) Target() (r string, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old "target" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTarget(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// ClearTarget clears the value of the "target" field.
func (m *MenuMutation) ClearTarget() {
	m.target = nil
	m.clearedFields[menu.FieldTarget] = struct{}{}
}

// TargetCleared returns if the "target" field was cleared in this mutation.
func (m *MenuMutation) TargetCleared() bool {
	_, ok := m.clearedFields[menu.FieldTarget]
	return ok
}

// ResetTarget resets all changes to the "target" field.
func (m *MenuMutation) ResetTarget() {
	m.target = nil
	delete(m.clearedFields, menu.FieldTarget)
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(u uint32) {
	m.parent_id = &u
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r uint32, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds u to the "parent_id" field.
func (m *MenuMutation) AddParentID(u int32) {
	if m.addparent_id != nil {
		*m.addparent_id += u
	} else {
		m.addparent_id = &u
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *MenuMutation) AddedParentID() (r int32, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetTeam sets the "team" field.
func (m *MenuMutation) SetTeam(s string) {
	m.team = &s
}

// Team returns the value of the "team" field in the mutation.
func (m *MenuMutation) Team() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeam returns the old "team" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTeam(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeam: %w", err)
	}
	return oldValue.Team, nil
}

// ClearTeam clears the value of the "team" field.
func (m *MenuMutation) ClearTeam() {
	m.team = nil
	m.clearedFields[menu.FieldTeam] = struct{}{}
}

// TeamCleared returns if the "team" field was cleared in this mutation.
func (m *MenuMutation) TeamCleared() bool {
	_, ok := m.clearedFields[menu.FieldTeam]
	return ok
}

// ResetTeam resets all changes to the "team" field.
func (m *MenuMutation) ResetTeam() {
	m.team = nil
	delete(m.clearedFields, menu.FieldTeam)
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, menu.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, menu.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, menu.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.url != nil {
		fields = append(fields, menu.FieldURL)
	}
	if m.priority != nil {
		fields = append(fields, menu.FieldPriority)
	}
	if m.target != nil {
		fields = append(fields, menu.FieldTarget)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.parent_id != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.team != nil {
		fields = append(fields, menu.FieldTeam)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreateTime:
		return m.CreateTime()
	case menu.FieldUpdateTime:
		return m.UpdateTime()
	case menu.FieldDeleteTime:
		return m.DeleteTime()
	case menu.FieldName:
		return m.Name()
	case menu.FieldURL:
		return m.URL()
	case menu.FieldPriority:
		return m.Priority()
	case menu.FieldTarget:
		return m.Target()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldTeam:
		return m.Team()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case menu.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case menu.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldURL:
		return m.OldURL(ctx)
	case menu.FieldPriority:
		return m.OldPriority(ctx)
	case menu.FieldTarget:
		return m.OldTarget(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldTeam:
		return m.OldTeam(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case menu.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case menu.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case menu.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case menu.FieldTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldTeam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeam(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, menu.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, menu.FieldUpdateTime)
	}
	if m.adddelete_time != nil {
		fields = append(fields, menu.FieldDeleteTime)
	}
	if m.addpriority != nil {
		fields = append(fields, menu.FieldPriority)
	}
	if m.addparent_id != nil {
		fields = append(fields, menu.FieldParentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreateTime:
		return m.AddedCreateTime()
	case menu.FieldUpdateTime:
		return m.AddedUpdateTime()
	case menu.FieldDeleteTime:
		return m.AddedDeleteTime()
	case menu.FieldPriority:
		return m.AddedPriority()
	case menu.FieldParentID:
		return m.AddedParentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case menu.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case menu.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case menu.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldCreateTime) {
		fields = append(fields, menu.FieldCreateTime)
	}
	if m.FieldCleared(menu.FieldUpdateTime) {
		fields = append(fields, menu.FieldUpdateTime)
	}
	if m.FieldCleared(menu.FieldDeleteTime) {
		fields = append(fields, menu.FieldDeleteTime)
	}
	if m.FieldCleared(menu.FieldName) {
		fields = append(fields, menu.FieldName)
	}
	if m.FieldCleared(menu.FieldURL) {
		fields = append(fields, menu.FieldURL)
	}
	if m.FieldCleared(menu.FieldPriority) {
		fields = append(fields, menu.FieldPriority)
	}
	if m.FieldCleared(menu.FieldTarget) {
		fields = append(fields, menu.FieldTarget)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldTeam) {
		fields = append(fields, menu.FieldTeam)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case menu.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case menu.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case menu.FieldName:
		m.ClearName()
		return nil
	case menu.FieldURL:
		m.ClearURL()
		return nil
	case menu.FieldPriority:
		m.ClearPriority()
		return nil
	case menu.FieldTarget:
		m.ClearTarget()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case menu.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case menu.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldURL:
		m.ResetURL()
		return nil
	case menu.FieldPriority:
		m.ResetPriority()
		return nil
	case menu.FieldTarget:
		m.ResetTarget()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Menu edge %s", name)
}

// PhotoMutation represents an operation that mutates the Photo nodes in the graph.
type PhotoMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	create_time    *int64
	addcreate_time *int64
	update_time    *int64
	addupdate_time *int64
	delete_time    *int64
	adddelete_time *int64
	name           *string
	thumbnail      *string
	take_time      *int64
	addtake_time   *int64
	url            *string
	team           *string
	location       *string
	description    *string
	likes          *int32
	addlikes       *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Photo, error)
	predicates     []predicate.Photo
}

var _ ent.Mutation = (*PhotoMutation)(nil)

// photoOption allows management of the mutation configuration using functional options.
type photoOption func(*PhotoMutation)

// newPhotoMutation creates new mutation for the Photo entity.
func newPhotoMutation(c config, op Op, opts ...photoOption) *PhotoMutation {
	m := &PhotoMutation{
		config:        c,
		op:            op,
		typ:           TypePhoto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhotoID sets the ID field of the mutation.
func withPhotoID(id uint32) photoOption {
	return func(m *PhotoMutation) {
		var (
			err   error
			once  sync.Once
			value *Photo
		)
		m.oldValue = func(ctx context.Context) (*Photo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Photo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhoto sets the old Photo of the mutation.
func withPhoto(node *Photo) photoOption {
	return func(m *PhotoMutation) {
		m.oldValue = func(context.Context) (*Photo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhotoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhotoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Photo entities.
func (m *PhotoMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhotoMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhotoMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Photo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PhotoMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PhotoMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldCreateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *PhotoMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *PhotoMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *PhotoMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[photo.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *PhotoMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[photo.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PhotoMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, photo.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *PhotoMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PhotoMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldUpdateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *PhotoMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *PhotoMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *PhotoMutation) ClearUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	m.clearedFields[photo.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *PhotoMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[photo.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PhotoMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	delete(m.clearedFields, photo.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *PhotoMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *PhotoMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldDeleteTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *PhotoMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *PhotoMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *PhotoMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	m.clearedFields[photo.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *PhotoMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[photo.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *PhotoMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	delete(m.clearedFields, photo.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *PhotoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PhotoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PhotoMutation) ClearName() {
	m.name = nil
	m.clearedFields[photo.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PhotoMutation) NameCleared() bool {
	_, ok := m.clearedFields[photo.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PhotoMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, photo.FieldName)
}

// SetThumbnail sets the "thumbnail" field.
func (m *PhotoMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *PhotoMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldThumbnail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *PhotoMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[photo.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *PhotoMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[photo.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *PhotoMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, photo.FieldThumbnail)
}

// SetTakeTime sets the "take_time" field.
func (m *PhotoMutation) SetTakeTime(i int64) {
	m.take_time = &i
	m.addtake_time = nil
}

// TakeTime returns the value of the "take_time" field in the mutation.
func (m *PhotoMutation) TakeTime() (r int64, exists bool) {
	v := m.take_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTakeTime returns the old "take_time" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldTakeTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakeTime: %w", err)
	}
	return oldValue.TakeTime, nil
}

// AddTakeTime adds i to the "take_time" field.
func (m *PhotoMutation) AddTakeTime(i int64) {
	if m.addtake_time != nil {
		*m.addtake_time += i
	} else {
		m.addtake_time = &i
	}
}

// AddedTakeTime returns the value that was added to the "take_time" field in this mutation.
func (m *PhotoMutation) AddedTakeTime() (r int64, exists bool) {
	v := m.addtake_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearTakeTime clears the value of the "take_time" field.
func (m *PhotoMutation) ClearTakeTime() {
	m.take_time = nil
	m.addtake_time = nil
	m.clearedFields[photo.FieldTakeTime] = struct{}{}
}

// TakeTimeCleared returns if the "take_time" field was cleared in this mutation.
func (m *PhotoMutation) TakeTimeCleared() bool {
	_, ok := m.clearedFields[photo.FieldTakeTime]
	return ok
}

// ResetTakeTime resets all changes to the "take_time" field.
func (m *PhotoMutation) ResetTakeTime() {
	m.take_time = nil
	m.addtake_time = nil
	delete(m.clearedFields, photo.FieldTakeTime)
}

// SetURL sets the "url" field.
func (m *PhotoMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PhotoMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *PhotoMutation) ClearURL() {
	m.url = nil
	m.clearedFields[photo.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *PhotoMutation) URLCleared() bool {
	_, ok := m.clearedFields[photo.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *PhotoMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, photo.FieldURL)
}

// SetTeam sets the "team" field.
func (m *PhotoMutation) SetTeam(s string) {
	m.team = &s
}

// Team returns the value of the "team" field in the mutation.
func (m *PhotoMutation) Team() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeam returns the old "team" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldTeam(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeam: %w", err)
	}
	return oldValue.Team, nil
}

// ClearTeam clears the value of the "team" field.
func (m *PhotoMutation) ClearTeam() {
	m.team = nil
	m.clearedFields[photo.FieldTeam] = struct{}{}
}

// TeamCleared returns if the "team" field was cleared in this mutation.
func (m *PhotoMutation) TeamCleared() bool {
	_, ok := m.clearedFields[photo.FieldTeam]
	return ok
}

// ResetTeam resets all changes to the "team" field.
func (m *PhotoMutation) ResetTeam() {
	m.team = nil
	delete(m.clearedFields, photo.FieldTeam)
}

// SetLocation sets the "location" field.
func (m *PhotoMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *PhotoMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *PhotoMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[photo.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *PhotoMutation) LocationCleared() bool {
	_, ok := m.clearedFields[photo.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *PhotoMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, photo.FieldLocation)
}

// SetDescription sets the "description" field.
func (m *PhotoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PhotoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PhotoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[photo.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PhotoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[photo.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PhotoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, photo.FieldDescription)
}

// SetLikes sets the "likes" field.
func (m *PhotoMutation) SetLikes(i int32) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *PhotoMutation) Likes() (r int32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldLikes(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *PhotoMutation) AddLikes(i int32) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *PhotoMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ClearLikes clears the value of the "likes" field.
func (m *PhotoMutation) ClearLikes() {
	m.likes = nil
	m.addlikes = nil
	m.clearedFields[photo.FieldLikes] = struct{}{}
}

// LikesCleared returns if the "likes" field was cleared in this mutation.
func (m *PhotoMutation) LikesCleared() bool {
	_, ok := m.clearedFields[photo.FieldLikes]
	return ok
}

// ResetLikes resets all changes to the "likes" field.
func (m *PhotoMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
	delete(m.clearedFields, photo.FieldLikes)
}

// Where appends a list predicates to the PhotoMutation builder.
func (m *PhotoMutation) Where(ps ...predicate.Photo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhotoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhotoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Photo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhotoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhotoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Photo).
func (m *PhotoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhotoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, photo.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, photo.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, photo.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, photo.FieldName)
	}
	if m.thumbnail != nil {
		fields = append(fields, photo.FieldThumbnail)
	}
	if m.take_time != nil {
		fields = append(fields, photo.FieldTakeTime)
	}
	if m.url != nil {
		fields = append(fields, photo.FieldURL)
	}
	if m.team != nil {
		fields = append(fields, photo.FieldTeam)
	}
	if m.location != nil {
		fields = append(fields, photo.FieldLocation)
	}
	if m.description != nil {
		fields = append(fields, photo.FieldDescription)
	}
	if m.likes != nil {
		fields = append(fields, photo.FieldLikes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhotoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case photo.FieldCreateTime:
		return m.CreateTime()
	case photo.FieldUpdateTime:
		return m.UpdateTime()
	case photo.FieldDeleteTime:
		return m.DeleteTime()
	case photo.FieldName:
		return m.Name()
	case photo.FieldThumbnail:
		return m.Thumbnail()
	case photo.FieldTakeTime:
		return m.TakeTime()
	case photo.FieldURL:
		return m.URL()
	case photo.FieldTeam:
		return m.Team()
	case photo.FieldLocation:
		return m.Location()
	case photo.FieldDescription:
		return m.Description()
	case photo.FieldLikes:
		return m.Likes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhotoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case photo.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case photo.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case photo.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case photo.FieldName:
		return m.OldName(ctx)
	case photo.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case photo.FieldTakeTime:
		return m.OldTakeTime(ctx)
	case photo.FieldURL:
		return m.OldURL(ctx)
	case photo.FieldTeam:
		return m.OldTeam(ctx)
	case photo.FieldLocation:
		return m.OldLocation(ctx)
	case photo.FieldDescription:
		return m.OldDescription(ctx)
	case photo.FieldLikes:
		return m.OldLikes(ctx)
	}
	return nil, fmt.Errorf("unknown Photo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhotoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case photo.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case photo.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case photo.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case photo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case photo.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case photo.FieldTakeTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakeTime(v)
		return nil
	case photo.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case photo.FieldTeam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeam(v)
		return nil
	case photo.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case photo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case photo.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	}
	return fmt.Errorf("unknown Photo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhotoMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, photo.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, photo.FieldUpdateTime)
	}
	if m.adddelete_time != nil {
		fields = append(fields, photo.FieldDeleteTime)
	}
	if m.addtake_time != nil {
		fields = append(fields, photo.FieldTakeTime)
	}
	if m.addlikes != nil {
		fields = append(fields, photo.FieldLikes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhotoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case photo.FieldCreateTime:
		return m.AddedCreateTime()
	case photo.FieldUpdateTime:
		return m.AddedUpdateTime()
	case photo.FieldDeleteTime:
		return m.AddedDeleteTime()
	case photo.FieldTakeTime:
		return m.AddedTakeTime()
	case photo.FieldLikes:
		return m.AddedLikes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhotoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case photo.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case photo.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case photo.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case photo.FieldTakeTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTakeTime(v)
		return nil
	case photo.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	}
	return fmt.Errorf("unknown Photo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhotoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(photo.FieldCreateTime) {
		fields = append(fields, photo.FieldCreateTime)
	}
	if m.FieldCleared(photo.FieldUpdateTime) {
		fields = append(fields, photo.FieldUpdateTime)
	}
	if m.FieldCleared(photo.FieldDeleteTime) {
		fields = append(fields, photo.FieldDeleteTime)
	}
	if m.FieldCleared(photo.FieldName) {
		fields = append(fields, photo.FieldName)
	}
	if m.FieldCleared(photo.FieldThumbnail) {
		fields = append(fields, photo.FieldThumbnail)
	}
	if m.FieldCleared(photo.FieldTakeTime) {
		fields = append(fields, photo.FieldTakeTime)
	}
	if m.FieldCleared(photo.FieldURL) {
		fields = append(fields, photo.FieldURL)
	}
	if m.FieldCleared(photo.FieldTeam) {
		fields = append(fields, photo.FieldTeam)
	}
	if m.FieldCleared(photo.FieldLocation) {
		fields = append(fields, photo.FieldLocation)
	}
	if m.FieldCleared(photo.FieldDescription) {
		fields = append(fields, photo.FieldDescription)
	}
	if m.FieldCleared(photo.FieldLikes) {
		fields = append(fields, photo.FieldLikes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhotoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhotoMutation) ClearField(name string) error {
	switch name {
	case photo.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case photo.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case photo.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case photo.FieldName:
		m.ClearName()
		return nil
	case photo.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	case photo.FieldTakeTime:
		m.ClearTakeTime()
		return nil
	case photo.FieldURL:
		m.ClearURL()
		return nil
	case photo.FieldTeam:
		m.ClearTeam()
		return nil
	case photo.FieldLocation:
		m.ClearLocation()
		return nil
	case photo.FieldDescription:
		m.ClearDescription()
		return nil
	case photo.FieldLikes:
		m.ClearLikes()
		return nil
	}
	return fmt.Errorf("unknown Photo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhotoMutation) ResetField(name string) error {
	switch name {
	case photo.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case photo.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case photo.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case photo.FieldName:
		m.ResetName()
		return nil
	case photo.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case photo.FieldTakeTime:
		m.ResetTakeTime()
		return nil
	case photo.FieldURL:
		m.ResetURL()
		return nil
	case photo.FieldTeam:
		m.ResetTeam()
		return nil
	case photo.FieldLocation:
		m.ResetLocation()
		return nil
	case photo.FieldDescription:
		m.ResetDescription()
		return nil
	case photo.FieldLikes:
		m.ResetLikes()
		return nil
	}
	return fmt.Errorf("unknown Photo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhotoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhotoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhotoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhotoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhotoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhotoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhotoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Photo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhotoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Photo edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	create_time      *int64
	addcreate_time   *int64
	update_time      *int64
	addupdate_time   *int64
	delete_time      *int64
	adddelete_time   *int64
	title            *string
	slug             *string
	meta_keywords    *string
	meta_description *string
	full_path        *string
	original_content *string
	content          *string
	summary          *string
	thumbnail        *string
	password         *string
	template         *string
	comment_count    *int32
	addcomment_count *int32
	visits           *int32
	addvisits        *int32
	likes            *int32
	addlikes         *int32
	word_count       *int32
	addword_count    *int32
	top_priority     *int32
	addtop_priority  *int32
	status           *int32
	addstatus        *int32
	editor_type      *int32
	addeditor_type   *int32
	edit_time        *int64
	addedit_time     *int64
	disallow_comment *bool
	in_progress      *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Post, error)
	predicates       []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id uint32) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PostMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PostMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *PostMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *PostMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *PostMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[post.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *PostMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[post.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PostMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, post.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *PostMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PostMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *PostMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *PostMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *PostMutation) ClearUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	m.clearedFields[post.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *PostMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[post.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PostMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	delete(m.clearedFields, post.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *PostMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *PostMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeleteTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *PostMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *PostMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *PostMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	m.clearedFields[post.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *PostMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[post.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *PostMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	delete(m.clearedFields, post.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PostMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[post.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PostMutation) TitleCleared() bool {
	_, ok := m.clearedFields[post.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, post.FieldTitle)
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[post.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostMutation) SlugCleared() bool {
	_, ok := m.clearedFields[post.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, post.FieldSlug)
}

// SetMetaKeywords sets the "meta_keywords" field.
func (m *PostMutation) SetMetaKeywords(s string) {
	m.meta_keywords = &s
}

// MetaKeywords returns the value of the "meta_keywords" field in the mutation.
func (m *PostMutation) MetaKeywords() (r string, exists bool) {
	v := m.meta_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaKeywords returns the old "meta_keywords" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetaKeywords(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaKeywords: %w", err)
	}
	return oldValue.MetaKeywords, nil
}

// ClearMetaKeywords clears the value of the "meta_keywords" field.
func (m *PostMutation) ClearMetaKeywords() {
	m.meta_keywords = nil
	m.clearedFields[post.FieldMetaKeywords] = struct{}{}
}

// MetaKeywordsCleared returns if the "meta_keywords" field was cleared in this mutation.
func (m *PostMutation) MetaKeywordsCleared() bool {
	_, ok := m.clearedFields[post.FieldMetaKeywords]
	return ok
}

// ResetMetaKeywords resets all changes to the "meta_keywords" field.
func (m *PostMutation) ResetMetaKeywords() {
	m.meta_keywords = nil
	delete(m.clearedFields, post.FieldMetaKeywords)
}

// SetMetaDescription sets the "meta_description" field.
func (m *PostMutation) SetMetaDescription(s string) {
	m.meta_description = &s
}

// MetaDescription returns the value of the "meta_description" field in the mutation.
func (m *PostMutation) MetaDescription() (r string, exists bool) {
	v := m.meta_description
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaDescription returns the old "meta_description" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetaDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaDescription: %w", err)
	}
	return oldValue.MetaDescription, nil
}

// ClearMetaDescription clears the value of the "meta_description" field.
func (m *PostMutation) ClearMetaDescription() {
	m.meta_description = nil
	m.clearedFields[post.FieldMetaDescription] = struct{}{}
}

// MetaDescriptionCleared returns if the "meta_description" field was cleared in this mutation.
func (m *PostMutation) MetaDescriptionCleared() bool {
	_, ok := m.clearedFields[post.FieldMetaDescription]
	return ok
}

// ResetMetaDescription resets all changes to the "meta_description" field.
func (m *PostMutation) ResetMetaDescription() {
	m.meta_description = nil
	delete(m.clearedFields, post.FieldMetaDescription)
}

// SetFullPath sets the "full_path" field.
func (m *PostMutation) SetFullPath(s string) {
	m.full_path = &s
}

// FullPath returns the value of the "full_path" field in the mutation.
func (m *PostMutation) FullPath() (r string, exists bool) {
	v := m.full_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFullPath returns the old "full_path" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldFullPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullPath: %w", err)
	}
	return oldValue.FullPath, nil
}

// ClearFullPath clears the value of the "full_path" field.
func (m *PostMutation) ClearFullPath() {
	m.full_path = nil
	m.clearedFields[post.FieldFullPath] = struct{}{}
}

// FullPathCleared returns if the "full_path" field was cleared in this mutation.
func (m *PostMutation) FullPathCleared() bool {
	_, ok := m.clearedFields[post.FieldFullPath]
	return ok
}

// ResetFullPath resets all changes to the "full_path" field.
func (m *PostMutation) ResetFullPath() {
	m.full_path = nil
	delete(m.clearedFields, post.FieldFullPath)
}

// SetOriginalContent sets the "original_content" field.
func (m *PostMutation) SetOriginalContent(s string) {
	m.original_content = &s
}

// OriginalContent returns the value of the "original_content" field in the mutation.
func (m *PostMutation) OriginalContent() (r string, exists bool) {
	v := m.original_content
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalContent returns the old "original_content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldOriginalContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalContent: %w", err)
	}
	return oldValue.OriginalContent, nil
}

// ClearOriginalContent clears the value of the "original_content" field.
func (m *PostMutation) ClearOriginalContent() {
	m.original_content = nil
	m.clearedFields[post.FieldOriginalContent] = struct{}{}
}

// OriginalContentCleared returns if the "original_content" field was cleared in this mutation.
func (m *PostMutation) OriginalContentCleared() bool {
	_, ok := m.clearedFields[post.FieldOriginalContent]
	return ok
}

// ResetOriginalContent resets all changes to the "original_content" field.
func (m *PostMutation) ResetOriginalContent() {
	m.original_content = nil
	delete(m.clearedFields, post.FieldOriginalContent)
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *PostMutation) ClearContent() {
	m.content = nil
	m.clearedFields[post.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *PostMutation) ContentCleared() bool {
	_, ok := m.clearedFields[post.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, post.FieldContent)
}

// SetSummary sets the "summary" field.
func (m *PostMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *PostMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSummary(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *PostMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[post.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *PostMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[post.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *PostMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, post.FieldSummary)
}

// SetThumbnail sets the "thumbnail" field.
func (m *PostMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *PostMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldThumbnail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *PostMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[post.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *PostMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[post.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *PostMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, post.FieldThumbnail)
}

// SetPassword sets the "password" field.
func (m *PostMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *PostMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *PostMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[post.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *PostMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[post.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *PostMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, post.FieldPassword)
}

// SetTemplate sets the "template" field.
func (m *PostMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *PostMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTemplate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ClearTemplate clears the value of the "template" field.
func (m *PostMutation) ClearTemplate() {
	m.template = nil
	m.clearedFields[post.FieldTemplate] = struct{}{}
}

// TemplateCleared returns if the "template" field was cleared in this mutation.
func (m *PostMutation) TemplateCleared() bool {
	_, ok := m.clearedFields[post.FieldTemplate]
	return ok
}

// ResetTemplate resets all changes to the "template" field.
func (m *PostMutation) ResetTemplate() {
	m.template = nil
	delete(m.clearedFields, post.FieldTemplate)
}

// SetCommentCount sets the "comment_count" field.
func (m *PostMutation) SetCommentCount(i int32) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *PostMutation) CommentCount() (r int32, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCommentCount(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *PostMutation) AddCommentCount(i int32) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *PostMutation) AddedCommentCount() (r int32, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommentCount clears the value of the "comment_count" field.
func (m *PostMutation) ClearCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	m.clearedFields[post.FieldCommentCount] = struct{}{}
}

// CommentCountCleared returns if the "comment_count" field was cleared in this mutation.
func (m *PostMutation) CommentCountCleared() bool {
	_, ok := m.clearedFields[post.FieldCommentCount]
	return ok
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *PostMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	delete(m.clearedFields, post.FieldCommentCount)
}

// SetVisits sets the "visits" field.
func (m *PostMutation) SetVisits(i int32) {
	m.visits = &i
	m.addvisits = nil
}

// Visits returns the value of the "visits" field in the mutation.
func (m *PostMutation) Visits() (r int32, exists bool) {
	v := m.visits
	if v == nil {
		return
	}
	return *v, true
}

// OldVisits returns the old "visits" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldVisits(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisits: %w", err)
	}
	return oldValue.Visits, nil
}

// AddVisits adds i to the "visits" field.
func (m *PostMutation) AddVisits(i int32) {
	if m.addvisits != nil {
		*m.addvisits += i
	} else {
		m.addvisits = &i
	}
}

// AddedVisits returns the value that was added to the "visits" field in this mutation.
func (m *PostMutation) AddedVisits() (r int32, exists bool) {
	v := m.addvisits
	if v == nil {
		return
	}
	return *v, true
}

// ClearVisits clears the value of the "visits" field.
func (m *PostMutation) ClearVisits() {
	m.visits = nil
	m.addvisits = nil
	m.clearedFields[post.FieldVisits] = struct{}{}
}

// VisitsCleared returns if the "visits" field was cleared in this mutation.
func (m *PostMutation) VisitsCleared() bool {
	_, ok := m.clearedFields[post.FieldVisits]
	return ok
}

// ResetVisits resets all changes to the "visits" field.
func (m *PostMutation) ResetVisits() {
	m.visits = nil
	m.addvisits = nil
	delete(m.clearedFields, post.FieldVisits)
}

// SetLikes sets the "likes" field.
func (m *PostMutation) SetLikes(i int32) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *PostMutation) Likes() (r int32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLikes(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *PostMutation) AddLikes(i int32) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *PostMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ClearLikes clears the value of the "likes" field.
func (m *PostMutation) ClearLikes() {
	m.likes = nil
	m.addlikes = nil
	m.clearedFields[post.FieldLikes] = struct{}{}
}

// LikesCleared returns if the "likes" field was cleared in this mutation.
func (m *PostMutation) LikesCleared() bool {
	_, ok := m.clearedFields[post.FieldLikes]
	return ok
}

// ResetLikes resets all changes to the "likes" field.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
	delete(m.clearedFields, post.FieldLikes)
}

// SetWordCount sets the "word_count" field.
func (m *PostMutation) SetWordCount(i int32) {
	m.word_count = &i
	m.addword_count = nil
}

// WordCount returns the value of the "word_count" field in the mutation.
func (m *PostMutation) WordCount() (r int32, exists bool) {
	v := m.word_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWordCount returns the old "word_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldWordCount(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordCount: %w", err)
	}
	return oldValue.WordCount, nil
}

// AddWordCount adds i to the "word_count" field.
func (m *PostMutation) AddWordCount(i int32) {
	if m.addword_count != nil {
		*m.addword_count += i
	} else {
		m.addword_count = &i
	}
}

// AddedWordCount returns the value that was added to the "word_count" field in this mutation.
func (m *PostMutation) AddedWordCount() (r int32, exists bool) {
	v := m.addword_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearWordCount clears the value of the "word_count" field.
func (m *PostMutation) ClearWordCount() {
	m.word_count = nil
	m.addword_count = nil
	m.clearedFields[post.FieldWordCount] = struct{}{}
}

// WordCountCleared returns if the "word_count" field was cleared in this mutation.
func (m *PostMutation) WordCountCleared() bool {
	_, ok := m.clearedFields[post.FieldWordCount]
	return ok
}

// ResetWordCount resets all changes to the "word_count" field.
func (m *PostMutation) ResetWordCount() {
	m.word_count = nil
	m.addword_count = nil
	delete(m.clearedFields, post.FieldWordCount)
}

// SetTopPriority sets the "top_priority" field.
func (m *PostMutation) SetTopPriority(i int32) {
	m.top_priority = &i
	m.addtop_priority = nil
}

// TopPriority returns the value of the "top_priority" field in the mutation.
func (m *PostMutation) TopPriority() (r int32, exists bool) {
	v := m.top_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldTopPriority returns the old "top_priority" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTopPriority(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopPriority: %w", err)
	}
	return oldValue.TopPriority, nil
}

// AddTopPriority adds i to the "top_priority" field.
func (m *PostMutation) AddTopPriority(i int32) {
	if m.addtop_priority != nil {
		*m.addtop_priority += i
	} else {
		m.addtop_priority = &i
	}
}

// AddedTopPriority returns the value that was added to the "top_priority" field in this mutation.
func (m *PostMutation) AddedTopPriority() (r int32, exists bool) {
	v := m.addtop_priority
	if v == nil {
		return
	}
	return *v, true
}

// ClearTopPriority clears the value of the "top_priority" field.
func (m *PostMutation) ClearTopPriority() {
	m.top_priority = nil
	m.addtop_priority = nil
	m.clearedFields[post.FieldTopPriority] = struct{}{}
}

// TopPriorityCleared returns if the "top_priority" field was cleared in this mutation.
func (m *PostMutation) TopPriorityCleared() bool {
	_, ok := m.clearedFields[post.FieldTopPriority]
	return ok
}

// ResetTopPriority resets all changes to the "top_priority" field.
func (m *PostMutation) ResetTopPriority() {
	m.top_priority = nil
	m.addtop_priority = nil
	delete(m.clearedFields, post.FieldTopPriority)
}

// SetStatus sets the "status" field.
func (m *PostMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PostMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldStatus(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *PostMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PostMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *PostMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[post.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PostMutation) StatusCleared() bool {
	_, ok := m.clearedFields[post.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PostMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, post.FieldStatus)
}

// SetEditorType sets the "editor_type" field.
func (m *PostMutation) SetEditorType(i int32) {
	m.editor_type = &i
	m.addeditor_type = nil
}

// EditorType returns the value of the "editor_type" field in the mutation.
func (m *PostMutation) EditorType() (r int32, exists bool) {
	v := m.editor_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEditorType returns the old "editor_type" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldEditorType(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditorType: %w", err)
	}
	return oldValue.EditorType, nil
}

// AddEditorType adds i to the "editor_type" field.
func (m *PostMutation) AddEditorType(i int32) {
	if m.addeditor_type != nil {
		*m.addeditor_type += i
	} else {
		m.addeditor_type = &i
	}
}

// AddedEditorType returns the value that was added to the "editor_type" field in this mutation.
func (m *PostMutation) AddedEditorType() (r int32, exists bool) {
	v := m.addeditor_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearEditorType clears the value of the "editor_type" field.
func (m *PostMutation) ClearEditorType() {
	m.editor_type = nil
	m.addeditor_type = nil
	m.clearedFields[post.FieldEditorType] = struct{}{}
}

// EditorTypeCleared returns if the "editor_type" field was cleared in this mutation.
func (m *PostMutation) EditorTypeCleared() bool {
	_, ok := m.clearedFields[post.FieldEditorType]
	return ok
}

// ResetEditorType resets all changes to the "editor_type" field.
func (m *PostMutation) ResetEditorType() {
	m.editor_type = nil
	m.addeditor_type = nil
	delete(m.clearedFields, post.FieldEditorType)
}

// SetEditTime sets the "edit_time" field.
func (m *PostMutation) SetEditTime(i int64) {
	m.edit_time = &i
	m.addedit_time = nil
}

// EditTime returns the value of the "edit_time" field in the mutation.
func (m *PostMutation) EditTime() (r int64, exists bool) {
	v := m.edit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEditTime returns the old "edit_time" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldEditTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditTime: %w", err)
	}
	return oldValue.EditTime, nil
}

// AddEditTime adds i to the "edit_time" field.
func (m *PostMutation) AddEditTime(i int64) {
	if m.addedit_time != nil {
		*m.addedit_time += i
	} else {
		m.addedit_time = &i
	}
}

// AddedEditTime returns the value that was added to the "edit_time" field in this mutation.
func (m *PostMutation) AddedEditTime() (r int64, exists bool) {
	v := m.addedit_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearEditTime clears the value of the "edit_time" field.
func (m *PostMutation) ClearEditTime() {
	m.edit_time = nil
	m.addedit_time = nil
	m.clearedFields[post.FieldEditTime] = struct{}{}
}

// EditTimeCleared returns if the "edit_time" field was cleared in this mutation.
func (m *PostMutation) EditTimeCleared() bool {
	_, ok := m.clearedFields[post.FieldEditTime]
	return ok
}

// ResetEditTime resets all changes to the "edit_time" field.
func (m *PostMutation) ResetEditTime() {
	m.edit_time = nil
	m.addedit_time = nil
	delete(m.clearedFields, post.FieldEditTime)
}

// SetDisallowComment sets the "disallow_comment" field.
func (m *PostMutation) SetDisallowComment(b bool) {
	m.disallow_comment = &b
}

// DisallowComment returns the value of the "disallow_comment" field in the mutation.
func (m *PostMutation) DisallowComment() (r bool, exists bool) {
	v := m.disallow_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldDisallowComment returns the old "disallow_comment" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDisallowComment(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisallowComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisallowComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisallowComment: %w", err)
	}
	return oldValue.DisallowComment, nil
}

// ClearDisallowComment clears the value of the "disallow_comment" field.
func (m *PostMutation) ClearDisallowComment() {
	m.disallow_comment = nil
	m.clearedFields[post.FieldDisallowComment] = struct{}{}
}

// DisallowCommentCleared returns if the "disallow_comment" field was cleared in this mutation.
func (m *PostMutation) DisallowCommentCleared() bool {
	_, ok := m.clearedFields[post.FieldDisallowComment]
	return ok
}

// ResetDisallowComment resets all changes to the "disallow_comment" field.
func (m *PostMutation) ResetDisallowComment() {
	m.disallow_comment = nil
	delete(m.clearedFields, post.FieldDisallowComment)
}

// SetInProgress sets the "in_progress" field.
func (m *PostMutation) SetInProgress(b bool) {
	m.in_progress = &b
}

// InProgress returns the value of the "in_progress" field in the mutation.
func (m *PostMutation) InProgress() (r bool, exists bool) {
	v := m.in_progress
	if v == nil {
		return
	}
	return *v, true
}

// OldInProgress returns the old "in_progress" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldInProgress(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInProgress: %w", err)
	}
	return oldValue.InProgress, nil
}

// ClearInProgress clears the value of the "in_progress" field.
func (m *PostMutation) ClearInProgress() {
	m.in_progress = nil
	m.clearedFields[post.FieldInProgress] = struct{}{}
}

// InProgressCleared returns if the "in_progress" field was cleared in this mutation.
func (m *PostMutation) InProgressCleared() bool {
	_, ok := m.clearedFields[post.FieldInProgress]
	return ok
}

// ResetInProgress resets all changes to the "in_progress" field.
func (m *PostMutation) ResetInProgress() {
	m.in_progress = nil
	delete(m.clearedFields, post.FieldInProgress)
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.create_time != nil {
		fields = append(fields, post.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, post.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, post.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.meta_keywords != nil {
		fields = append(fields, post.FieldMetaKeywords)
	}
	if m.meta_description != nil {
		fields = append(fields, post.FieldMetaDescription)
	}
	if m.full_path != nil {
		fields = append(fields, post.FieldFullPath)
	}
	if m.original_content != nil {
		fields = append(fields, post.FieldOriginalContent)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.summary != nil {
		fields = append(fields, post.FieldSummary)
	}
	if m.thumbnail != nil {
		fields = append(fields, post.FieldThumbnail)
	}
	if m.password != nil {
		fields = append(fields, post.FieldPassword)
	}
	if m.template != nil {
		fields = append(fields, post.FieldTemplate)
	}
	if m.comment_count != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	if m.visits != nil {
		fields = append(fields, post.FieldVisits)
	}
	if m.likes != nil {
		fields = append(fields, post.FieldLikes)
	}
	if m.word_count != nil {
		fields = append(fields, post.FieldWordCount)
	}
	if m.top_priority != nil {
		fields = append(fields, post.FieldTopPriority)
	}
	if m.status != nil {
		fields = append(fields, post.FieldStatus)
	}
	if m.editor_type != nil {
		fields = append(fields, post.FieldEditorType)
	}
	if m.edit_time != nil {
		fields = append(fields, post.FieldEditTime)
	}
	if m.disallow_comment != nil {
		fields = append(fields, post.FieldDisallowComment)
	}
	if m.in_progress != nil {
		fields = append(fields, post.FieldInProgress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreateTime:
		return m.CreateTime()
	case post.FieldUpdateTime:
		return m.UpdateTime()
	case post.FieldDeleteTime:
		return m.DeleteTime()
	case post.FieldTitle:
		return m.Title()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldMetaKeywords:
		return m.MetaKeywords()
	case post.FieldMetaDescription:
		return m.MetaDescription()
	case post.FieldFullPath:
		return m.FullPath()
	case post.FieldOriginalContent:
		return m.OriginalContent()
	case post.FieldContent:
		return m.Content()
	case post.FieldSummary:
		return m.Summary()
	case post.FieldThumbnail:
		return m.Thumbnail()
	case post.FieldPassword:
		return m.Password()
	case post.FieldTemplate:
		return m.Template()
	case post.FieldCommentCount:
		return m.CommentCount()
	case post.FieldVisits:
		return m.Visits()
	case post.FieldLikes:
		return m.Likes()
	case post.FieldWordCount:
		return m.WordCount()
	case post.FieldTopPriority:
		return m.TopPriority()
	case post.FieldStatus:
		return m.Status()
	case post.FieldEditorType:
		return m.EditorType()
	case post.FieldEditTime:
		return m.EditTime()
	case post.FieldDisallowComment:
		return m.DisallowComment()
	case post.FieldInProgress:
		return m.InProgress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case post.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case post.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldMetaKeywords:
		return m.OldMetaKeywords(ctx)
	case post.FieldMetaDescription:
		return m.OldMetaDescription(ctx)
	case post.FieldFullPath:
		return m.OldFullPath(ctx)
	case post.FieldOriginalContent:
		return m.OldOriginalContent(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldSummary:
		return m.OldSummary(ctx)
	case post.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case post.FieldPassword:
		return m.OldPassword(ctx)
	case post.FieldTemplate:
		return m.OldTemplate(ctx)
	case post.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case post.FieldVisits:
		return m.OldVisits(ctx)
	case post.FieldLikes:
		return m.OldLikes(ctx)
	case post.FieldWordCount:
		return m.OldWordCount(ctx)
	case post.FieldTopPriority:
		return m.OldTopPriority(ctx)
	case post.FieldStatus:
		return m.OldStatus(ctx)
	case post.FieldEditorType:
		return m.OldEditorType(ctx)
	case post.FieldEditTime:
		return m.OldEditTime(ctx)
	case post.FieldDisallowComment:
		return m.OldDisallowComment(ctx)
	case post.FieldInProgress:
		return m.OldInProgress(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case post.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case post.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldMetaKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaKeywords(v)
		return nil
	case post.FieldMetaDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaDescription(v)
		return nil
	case post.FieldFullPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullPath(v)
		return nil
	case post.FieldOriginalContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalContent(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case post.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case post.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case post.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case post.FieldVisits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisits(v)
		return nil
	case post.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case post.FieldWordCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordCount(v)
		return nil
	case post.FieldTopPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopPriority(v)
		return nil
	case post.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case post.FieldEditorType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditorType(v)
		return nil
	case post.FieldEditTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditTime(v)
		return nil
	case post.FieldDisallowComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisallowComment(v)
		return nil
	case post.FieldInProgress:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, post.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, post.FieldUpdateTime)
	}
	if m.adddelete_time != nil {
		fields = append(fields, post.FieldDeleteTime)
	}
	if m.addcomment_count != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	if m.addvisits != nil {
		fields = append(fields, post.FieldVisits)
	}
	if m.addlikes != nil {
		fields = append(fields, post.FieldLikes)
	}
	if m.addword_count != nil {
		fields = append(fields, post.FieldWordCount)
	}
	if m.addtop_priority != nil {
		fields = append(fields, post.FieldTopPriority)
	}
	if m.addstatus != nil {
		fields = append(fields, post.FieldStatus)
	}
	if m.addeditor_type != nil {
		fields = append(fields, post.FieldEditorType)
	}
	if m.addedit_time != nil {
		fields = append(fields, post.FieldEditTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreateTime:
		return m.AddedCreateTime()
	case post.FieldUpdateTime:
		return m.AddedUpdateTime()
	case post.FieldDeleteTime:
		return m.AddedDeleteTime()
	case post.FieldCommentCount:
		return m.AddedCommentCount()
	case post.FieldVisits:
		return m.AddedVisits()
	case post.FieldLikes:
		return m.AddedLikes()
	case post.FieldWordCount:
		return m.AddedWordCount()
	case post.FieldTopPriority:
		return m.AddedTopPriority()
	case post.FieldStatus:
		return m.AddedStatus()
	case post.FieldEditorType:
		return m.AddedEditorType()
	case post.FieldEditTime:
		return m.AddedEditTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case post.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case post.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case post.FieldVisits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisits(v)
		return nil
	case post.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	case post.FieldWordCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordCount(v)
		return nil
	case post.FieldTopPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTopPriority(v)
		return nil
	case post.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case post.FieldEditorType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEditorType(v)
		return nil
	case post.FieldEditTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEditTime(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldCreateTime) {
		fields = append(fields, post.FieldCreateTime)
	}
	if m.FieldCleared(post.FieldUpdateTime) {
		fields = append(fields, post.FieldUpdateTime)
	}
	if m.FieldCleared(post.FieldDeleteTime) {
		fields = append(fields, post.FieldDeleteTime)
	}
	if m.FieldCleared(post.FieldTitle) {
		fields = append(fields, post.FieldTitle)
	}
	if m.FieldCleared(post.FieldSlug) {
		fields = append(fields, post.FieldSlug)
	}
	if m.FieldCleared(post.FieldMetaKeywords) {
		fields = append(fields, post.FieldMetaKeywords)
	}
	if m.FieldCleared(post.FieldMetaDescription) {
		fields = append(fields, post.FieldMetaDescription)
	}
	if m.FieldCleared(post.FieldFullPath) {
		fields = append(fields, post.FieldFullPath)
	}
	if m.FieldCleared(post.FieldOriginalContent) {
		fields = append(fields, post.FieldOriginalContent)
	}
	if m.FieldCleared(post.FieldContent) {
		fields = append(fields, post.FieldContent)
	}
	if m.FieldCleared(post.FieldSummary) {
		fields = append(fields, post.FieldSummary)
	}
	if m.FieldCleared(post.FieldThumbnail) {
		fields = append(fields, post.FieldThumbnail)
	}
	if m.FieldCleared(post.FieldPassword) {
		fields = append(fields, post.FieldPassword)
	}
	if m.FieldCleared(post.FieldTemplate) {
		fields = append(fields, post.FieldTemplate)
	}
	if m.FieldCleared(post.FieldCommentCount) {
		fields = append(fields, post.FieldCommentCount)
	}
	if m.FieldCleared(post.FieldVisits) {
		fields = append(fields, post.FieldVisits)
	}
	if m.FieldCleared(post.FieldLikes) {
		fields = append(fields, post.FieldLikes)
	}
	if m.FieldCleared(post.FieldWordCount) {
		fields = append(fields, post.FieldWordCount)
	}
	if m.FieldCleared(post.FieldTopPriority) {
		fields = append(fields, post.FieldTopPriority)
	}
	if m.FieldCleared(post.FieldStatus) {
		fields = append(fields, post.FieldStatus)
	}
	if m.FieldCleared(post.FieldEditorType) {
		fields = append(fields, post.FieldEditorType)
	}
	if m.FieldCleared(post.FieldEditTime) {
		fields = append(fields, post.FieldEditTime)
	}
	if m.FieldCleared(post.FieldDisallowComment) {
		fields = append(fields, post.FieldDisallowComment)
	}
	if m.FieldCleared(post.FieldInProgress) {
		fields = append(fields, post.FieldInProgress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case post.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case post.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case post.FieldTitle:
		m.ClearTitle()
		return nil
	case post.FieldSlug:
		m.ClearSlug()
		return nil
	case post.FieldMetaKeywords:
		m.ClearMetaKeywords()
		return nil
	case post.FieldMetaDescription:
		m.ClearMetaDescription()
		return nil
	case post.FieldFullPath:
		m.ClearFullPath()
		return nil
	case post.FieldOriginalContent:
		m.ClearOriginalContent()
		return nil
	case post.FieldContent:
		m.ClearContent()
		return nil
	case post.FieldSummary:
		m.ClearSummary()
		return nil
	case post.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	case post.FieldPassword:
		m.ClearPassword()
		return nil
	case post.FieldTemplate:
		m.ClearTemplate()
		return nil
	case post.FieldCommentCount:
		m.ClearCommentCount()
		return nil
	case post.FieldVisits:
		m.ClearVisits()
		return nil
	case post.FieldLikes:
		m.ClearLikes()
		return nil
	case post.FieldWordCount:
		m.ClearWordCount()
		return nil
	case post.FieldTopPriority:
		m.ClearTopPriority()
		return nil
	case post.FieldStatus:
		m.ClearStatus()
		return nil
	case post.FieldEditorType:
		m.ClearEditorType()
		return nil
	case post.FieldEditTime:
		m.ClearEditTime()
		return nil
	case post.FieldDisallowComment:
		m.ClearDisallowComment()
		return nil
	case post.FieldInProgress:
		m.ClearInProgress()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case post.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case post.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldMetaKeywords:
		m.ResetMetaKeywords()
		return nil
	case post.FieldMetaDescription:
		m.ResetMetaDescription()
		return nil
	case post.FieldFullPath:
		m.ResetFullPath()
		return nil
	case post.FieldOriginalContent:
		m.ResetOriginalContent()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldSummary:
		m.ResetSummary()
		return nil
	case post.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case post.FieldPassword:
		m.ResetPassword()
		return nil
	case post.FieldTemplate:
		m.ResetTemplate()
		return nil
	case post.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case post.FieldVisits:
		m.ResetVisits()
		return nil
	case post.FieldLikes:
		m.ResetLikes()
		return nil
	case post.FieldWordCount:
		m.ResetWordCount()
		return nil
	case post.FieldTopPriority:
		m.ResetTopPriority()
		return nil
	case post.FieldStatus:
		m.ResetStatus()
		return nil
	case post.FieldEditorType:
		m.ResetEditorType()
		return nil
	case post.FieldEditTime:
		m.ResetEditTime()
		return nil
	case post.FieldDisallowComment:
		m.ResetDisallowComment()
		return nil
	case post.FieldInProgress:
		m.ResetInProgress()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Post edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	create_time    *int64
	addcreate_time *int64
	update_time    *int64
	addupdate_time *int64
	delete_time    *int64
	adddelete_time *int64
	name           *string
	color          *string
	thumbnail      *string
	slug           *string
	slug_name      *string
	post_count     *uint32
	addpost_count  *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Tag, error)
	predicates     []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uint32) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TagMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TagMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *TagMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *TagMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *TagMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[tag.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *TagMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[tag.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TagMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, tag.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *TagMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TagMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdateTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *TagMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *TagMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *TagMutation) ClearUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	m.clearedFields[tag.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *TagMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[tag.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TagMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
	delete(m.clearedFields, tag.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *TagMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *TagMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeleteTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *TagMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *TagMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *TagMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	m.clearedFields[tag.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *TagMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *TagMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
	delete(m.clearedFields, tag.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TagMutation) ClearName() {
	m.name = nil
	m.clearedFields[tag.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TagMutation) NameCleared() bool {
	_, ok := m.clearedFields[tag.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, tag.FieldName)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// SetThumbnail sets the "thumbnail" field.
func (m *TagMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *TagMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldThumbnail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *TagMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[tag.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *TagMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[tag.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *TagMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, tag.FieldThumbnail)
}

// SetSlug sets the "slug" field.
func (m *TagMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TagMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *TagMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[tag.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *TagMutation) SlugCleared() bool {
	_, ok := m.clearedFields[tag.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *TagMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, tag.FieldSlug)
}

// SetSlugName sets the "slug_name" field.
func (m *TagMutation) SetSlugName(s string) {
	m.slug_name = &s
}

// SlugName returns the value of the "slug_name" field in the mutation.
func (m *TagMutation) SlugName() (r string, exists bool) {
	v := m.slug_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSlugName returns the old "slug_name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldSlugName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlugName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlugName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlugName: %w", err)
	}
	return oldValue.SlugName, nil
}

// ClearSlugName clears the value of the "slug_name" field.
func (m *TagMutation) ClearSlugName() {
	m.slug_name = nil
	m.clearedFields[tag.FieldSlugName] = struct{}{}
}

// SlugNameCleared returns if the "slug_name" field was cleared in this mutation.
func (m *TagMutation) SlugNameCleared() bool {
	_, ok := m.clearedFields[tag.FieldSlugName]
	return ok
}

// ResetSlugName resets all changes to the "slug_name" field.
func (m *TagMutation) ResetSlugName() {
	m.slug_name = nil
	delete(m.clearedFields, tag.FieldSlugName)
}

// SetPostCount sets the "post_count" field.
func (m *TagMutation) SetPostCount(u uint32) {
	m.post_count = &u
	m.addpost_count = nil
}

// PostCount returns the value of the "post_count" field in the mutation.
func (m *TagMutation) PostCount() (r uint32, exists bool) {
	v := m.post_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCount returns the old "post_count" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldPostCount(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCount: %w", err)
	}
	return oldValue.PostCount, nil
}

// AddPostCount adds u to the "post_count" field.
func (m *TagMutation) AddPostCount(u int32) {
	if m.addpost_count != nil {
		*m.addpost_count += u
	} else {
		m.addpost_count = &u
	}
}

// AddedPostCount returns the value that was added to the "post_count" field in this mutation.
func (m *TagMutation) AddedPostCount() (r int32, exists bool) {
	v := m.addpost_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearPostCount clears the value of the "post_count" field.
func (m *TagMutation) ClearPostCount() {
	m.post_count = nil
	m.addpost_count = nil
	m.clearedFields[tag.FieldPostCount] = struct{}{}
}

// PostCountCleared returns if the "post_count" field was cleared in this mutation.
func (m *TagMutation) PostCountCleared() bool {
	_, ok := m.clearedFields[tag.FieldPostCount]
	return ok
}

// ResetPostCount resets all changes to the "post_count" field.
func (m *TagMutation) ResetPostCount() {
	m.post_count = nil
	m.addpost_count = nil
	delete(m.clearedFields, tag.FieldPostCount)
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, tag.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tag.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, tag.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	if m.thumbnail != nil {
		fields = append(fields, tag.FieldThumbnail)
	}
	if m.slug != nil {
		fields = append(fields, tag.FieldSlug)
	}
	if m.slug_name != nil {
		fields = append(fields, tag.FieldSlugName)
	}
	if m.post_count != nil {
		fields = append(fields, tag.FieldPostCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreateTime:
		return m.CreateTime()
	case tag.FieldUpdateTime:
		return m.UpdateTime()
	case tag.FieldDeleteTime:
		return m.DeleteTime()
	case tag.FieldName:
		return m.Name()
	case tag.FieldColor:
		return m.Color()
	case tag.FieldThumbnail:
		return m.Thumbnail()
	case tag.FieldSlug:
		return m.Slug()
	case tag.FieldSlugName:
		return m.SlugName()
	case tag.FieldPostCount:
		return m.PostCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tag.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tag.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	case tag.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case tag.FieldSlug:
		return m.OldSlug(ctx)
	case tag.FieldSlugName:
		return m.OldSlugName(ctx)
	case tag.FieldPostCount:
		return m.OldPostCount(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tag.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tag.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tag.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case tag.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case tag.FieldSlugName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlugName(v)
		return nil
	case tag.FieldPostCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCount(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, tag.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, tag.FieldUpdateTime)
	}
	if m.adddelete_time != nil {
		fields = append(fields, tag.FieldDeleteTime)
	}
	if m.addpost_count != nil {
		fields = append(fields, tag.FieldPostCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreateTime:
		return m.AddedCreateTime()
	case tag.FieldUpdateTime:
		return m.AddedUpdateTime()
	case tag.FieldDeleteTime:
		return m.AddedDeleteTime()
	case tag.FieldPostCount:
		return m.AddedPostCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case tag.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case tag.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case tag.FieldPostCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCount(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldCreateTime) {
		fields = append(fields, tag.FieldCreateTime)
	}
	if m.FieldCleared(tag.FieldUpdateTime) {
		fields = append(fields, tag.FieldUpdateTime)
	}
	if m.FieldCleared(tag.FieldDeleteTime) {
		fields = append(fields, tag.FieldDeleteTime)
	}
	if m.FieldCleared(tag.FieldName) {
		fields = append(fields, tag.FieldName)
	}
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	if m.FieldCleared(tag.FieldThumbnail) {
		fields = append(fields, tag.FieldThumbnail)
	}
	if m.FieldCleared(tag.FieldSlug) {
		fields = append(fields, tag.FieldSlug)
	}
	if m.FieldCleared(tag.FieldSlugName) {
		fields = append(fields, tag.FieldSlugName)
	}
	if m.FieldCleared(tag.FieldPostCount) {
		fields = append(fields, tag.FieldPostCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case tag.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case tag.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case tag.FieldName:
		m.ClearName()
		return nil
	case tag.FieldColor:
		m.ClearColor()
		return nil
	case tag.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	case tag.FieldSlug:
		m.ClearSlug()
		return nil
	case tag.FieldSlugName:
		m.ClearSlugName()
		return nil
	case tag.FieldPostCount:
		m.ClearPostCount()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tag.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tag.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	case tag.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case tag.FieldSlug:
		m.ResetSlug()
		return nil
	case tag.FieldSlugName:
		m.ResetSlugName()
		return nil
	case tag.FieldPostCount:
		m.ResetPostCount()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}
